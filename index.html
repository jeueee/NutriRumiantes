<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåø Folia Scan Web</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- OpenCV.js CDN (Librer√≠a de Visi√≥n por Computadora) -->
    <script async src="https://docs.opencv.org/4.9.0/opencv.js" onload="onOpenCvReady()"></script>
    <style>
        /* Estilo para la fuente Inter y fondo */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
        }
        /* Estilos espec√≠ficos para las vistas de imagen/canvas */
        .image-container {
            min-height: 300px;
            background-color: #e2e8f0;
            border: 2px dashed #94a3b8;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            border-radius: 0.5rem;
            position: relative;
        }
        canvas, #originalImage {
            max-width: 100%;
            height: auto;
            position: absolute; /* Para que el canvas se superponga o tome el espacio */
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            margin: auto;
        }
        /* Ocultar el input de archivo */
        #fileInput {
            display: none;
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="max-w-7xl mx-auto">
        <h1 class="text-4xl font-extrabold mb-2 text-gray-900 flex items-center">
            <span class="text-green-700 mr-3">üåø</span> Folia Scan Web (Tiempo Real)
        </h1>
        <p class="text-gray-600 mb-6">Visualice los contornos de la hoja y el cuadrado en tiempo real antes de medir.</p>

        <!-- Contenedor Principal: Ajustes y Vistas -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">

            <!-- Panel de Control y Ajustes (Columna 1) -->
            <div class="lg:col-span-1 space-y-6">

                <!-- √Årea de Calibraci√≥n -->
                <div class="bg-white p-6 rounded-xl shadow-lg border border-gray-100">
                    <h2 class="text-xl font-semibold mb-3 text-green-700">üìè Calibraci√≥n de Escala</h2>
                    <p class="text-sm text-gray-500 mb-4">Ingrese la longitud real (en cm) del cuadrado de referencia. El cuadrado debe contrastar con el fondo.</p>
                    
                    <div class="flex items-center space-x-3 mb-4">
                        <label for="scaleCm" class="block text-sm font-medium text-gray-700">Lado Real (cm)</label>
                        <input type="number" id="scaleCm" value="1.0" min="0.1" step="0.1"
                               class="mt-1 block w-20 rounded-md border-gray-300 shadow-sm focus:border-green-500 focus:ring-green-500 p-2 border text-right">
                    </div>
                    
                    <button id="btnMeasure" onclick="measureFinalImage()" disabled
                            class="w-full bg-blue-600 text-white py-2 px-4 rounded-lg hover:bg-blue-700 transition duration-150 shadow-md disabled:bg-gray-400">
                        üìê Tomar Foto y Medir
                    </button>
                    <p id="calibrationStatus" class="mt-2 text-sm text-red-500 font-medium">Cargando OpenCV.js...</p>
                </div>

                <!-- Panel de Carga de Imagen -->
                <div class="bg-white p-6 rounded-xl shadow-lg border border-gray-100">
                    <h2 class="text-xl font-semibold mb-3 text-green-700">üì∏ Opciones de Entrada</h2>
                    <div class="space-y-3">
                        <button onclick="document.getElementById('fileInput').click()"
                                class="w-full bg-green-600 text-white py-2 px-4 rounded-lg hover:bg-green-700 transition duration-150 shadow-md">
                            Subir Imagen Local
                        </button>
                        <input type="file" id="fileInput" accept="image/*" onchange="handleFile(event)">
                        
                        <button id="btnCamera" onclick="startCamera()"
                                class="w-full bg-indigo-600 text-white py-2 px-4 rounded-lg hover:bg-indigo-700 transition duration-150 shadow-md">
                            Iniciar C√°mara y Streaming CV
                        </button>
                        <button id="btnStopCamera" onclick="stopCamera()" disabled
                                class="w-full bg-red-600 text-white py-2 px-4 rounded-lg hover:bg-red-700 transition duration-150 shadow-md hidden">
                            Detener C√°mara
                        </button>
                        <p class="text-xs text-gray-500 mt-2">Al iniciar la c√°mara, el procesamiento se activa en el visor de resultados.</p>
                    </div>
                </div>
            </div>
            
            <!-- Vistas y Resultados (Columnas 2 & 3) -->
            <div class="lg:col-span-2 space-y-6">
                <!-- Visores de Imagen -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <!-- Vista de la C√°mara/Original (Video) -->
                    <div>
                        <h3 class="text-lg font-semibold mb-2 text-gray-700">Fuente de Entrada (C√°mara/Imagen)</h3>
                        <div class="image-container">
                            <!-- El video feed y la imagen se muestran aqu√≠ -->
                            <video id="webcamFeed" class="hidden" autoplay playsinline></video>
                            <img id="originalImage" class="hidden" alt="Imagen Original">
                            <p id="placeholderText" class="text-gray-500 text-center p-4">Cargue una imagen o inicie la c√°mara.</p>
                        </div>
                    </div>

                    <!-- Vista Procesada (Canvas con Contornos en Tiempo Real) -->
                    <div>
                        <h3 class="text-lg font-semibold mb-2 text-gray-700">Visualizaci√≥n de Contornos (Real Time)</h3>
                        <div class="image-container">
                            <!-- El canvas para el procesamiento en vivo -->
                            <canvas id="processedCanvas" class="hidden"></canvas>
                            <p id="canvasPlaceholder" class="text-gray-500 text-center p-4">Aqu√≠ se mostrar√° el modelo de CV.</p>
                        </div>
                    </div>
                </div>

                <!-- Resultados de Medici√≥n -->
                <div class="bg-white p-6 rounded-xl shadow-lg border border-gray-100">
                    <h2 class="text-xl font-semibold mb-3 text-green-700">üìä Resultados de la Medici√≥n Final</h2>
                    <div id="results" class="space-y-2 text-gray-700">
                        <p id="areaResult" class="text-lg font-medium">√Årea de la Hoja: <span class="font-bold text-gray-500">N/A</span></p>
                        <p id="perimeterResult" class="text-lg font-medium">Per√≠metro de la Hoja: <span class="font-bold text-gray-500">N/A</span></p>
                        <p id="lengthResult" class="text-lg font-medium">Largo M√°ximo (L): <span class="font-bold text-gray-500">N/A</span></p>
                        <p id="widthResult" class="text-lg font-medium">Ancho M√°ximo (A): <span class="font-bold text-gray-500">N/A</span></p>
                        <p id="pixelCm" class="text-sm">Escala (P√≠xeles/cm): <span class="font-bold text-gray-500">N/A</span></p>
                        <p id="processingTime" class="text-sm">Tiempo de Proceso (√∫ltima medici√≥n): <span class="font-bold text-gray-500">N/A</span></p>
                    </div>
                </div>
                
            </div>
        </div>
    </div>
    <!-- Modal de Alerta (Reemplazo de alert()) -->
    <div id="alertModal" class="fixed inset-0 bg-gray-600 bg-opacity-50 hidden items-center justify-center p-4 z-50">
        <div class="bg-white rounded-lg shadow-2xl p-6 w-full max-w-sm">
            <h3 class="text-xl font-bold mb-4 text-red-600">Alerta del Sistema</h3>
            <p id="alertMessage" class="text-gray-700 mb-6"></p>
            <button onclick="closeAlertModal()" class="w-full bg-red-600 text-white py-2 rounded-lg hover:bg-red-700 transition">Cerrar</button>
        </div>
    </div>

    <script>
        // =======================================================
        // CONSTANTES GLOBALES Y VARIABLES DE ESTADO
        // =======================================================
        const Config = {
            SQUARE_ASPECT_RATIO_MIN: 0.85,
            SQUARE_ASPECT_RATIO_MAX: 1.15,
            MIN_CONTOUR_AREA_PX: 1000,
            THRESHOLD_VALUE: 100, // Valor de binarizaci√≥n inicial
        };

        let imageBase64 = null; 
        let stream = null;      
        let pixelsPerCm = null; 
        let cvReady = false; 
        let streaming = false; // Nueva bandera para el loop de streaming
        let lastFrame = null; // Para almacenar el √∫ltimo frame para la medici√≥n

        const $ = (id) => document.getElementById(id);
        const elements = {
            originalImage: $('originalImage'),
            processedCanvas: $('processedCanvas'),
            webcamFeed: $('webcamFeed'),
            placeholderText: $('placeholderText'),
            btnMeasure: $('btnMeasure'), // Renombrado de btnCalibrate
            btnCamera: $('btnCamera'),
            btnStopCamera: $('btnStopCamera'),
            scaleCm: $('scaleCm'),
            calibrationStatus: $('calibrationStatus'),
            areaResult: $('areaResult').querySelector('span'),
            perimeterResult: $('perimeterResult').querySelector('span'),
            lengthResult: $('lengthResult').querySelector('span'), 
            widthResult: $('widthResult').querySelector('span'),   
            pixelCm: $('pixelCm').querySelector('span'),
            processingTime: $('processingTime').querySelector('span'),
            alertModal: $('alertModal'),
            alertMessage: $('alertMessage'),
            canvasPlaceholder: $('canvasPlaceholder')
        };

        /**
         * Maneja el mensaje de carga de OpenCV.js
         */
        function onOpenCvReady() {
            cvReady = true;
            elements.btnMeasure.disabled = false;
            elements.calibrationStatus.textContent = "‚úÖ OpenCV.js listo. Inicie la c√°mara o cargue una imagen.";
            elements.calibrationStatus.classList.remove('text-red-500');
            elements.calibrationStatus.classList.add('text-gray-600');
        }
        
        // =======================================================
        // UTILIDADES Y MODALES
        // =======================================================

        /** Muestra un modal de alerta personalizado */
        function showAlertModal(message) {
            elements.alertMessage.textContent = message;
            elements.alertModal.classList.remove('hidden');
            elements.alertModal.classList.add('flex');
        }

        /** Cierra el modal de alerta. */
        function closeAlertModal() {
            elements.alertModal.classList.add('hidden');
            elements.alertModal.classList.remove('flex');
        }

        /**
         * Inicializa la imagen y el canvas de resultados.
         * @param {cv.Mat} srcMat - La Mat de OpenCV que contiene el frame o imagen.
         * @returns {HTMLCanvasElement} El canvas temporal para el procesamiento.
         */
        function initializeCanvas(srcMat) {
            // Ajustar el tama√±o del canvas de procesamiento al tama√±o de la imagen/video
            const width = srcMat.cols;
            const height = srcMat.rows;
            
            elements.processedCanvas.width = width;
            elements.processedCanvas.height = height;
            
            // Tambi√©n ajustamos el video/imagen original para que se muestre correctamente
            elements.webcamFeed.style.width = width + 'px';
            elements.webcamFeed.style.height = height + 'px';
            elements.originalImage.style.width = width + 'px';
            elements.originalImage.style.height = height + 'px';
            
            return elements.processedCanvas;
        }


        // =======================================================
        // FUNCI√ìN CENTRAL DE VISI√ìN POR COMPUTADORA (OpenCV.js)
        // =======================================================

        /**
         * Realiza el procesamiento de imagen, detecci√≥n de contornos, calibraci√≥n y medici√≥n.
         * @param {cv.Mat} src - La Mat de OpenCV que contiene el frame o imagen.
         * @param {HTMLCanvasElement} canvasOutput - El canvas donde dibujar el resultado.
         * @param {boolean} calculateMetrics - Si se deben calcular las m√©tricas finales (√Årea, Per√≠metro, etc.)
         * @returns {Object|null} - {areaCm2, perimeterCm, lengthCm, widthCm, calibrationSuccess}
         */
        function processImage(src, canvasOutput, calculateMetrics = false) {
            
            const startTime = performance.now();
            let gray = null;
            let binary = null;
            let contours = null;
            let hierarchy = null;
            let dst = null; // Destination Mat for drawing

            try {
                // Preprocesamiento (Escala de grises y Binarizaci√≥n)
                gray = new cv.Mat();
                binary = new cv.Mat();
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
                cv.threshold(gray, binary, Config.THRESHOLD_VALUE, 255, cv.THRESH_BINARY_INV);
                
                // Encontrar Contornos
                contours = new cv.MatVector();
                hierarchy = new cv.Mat();
                cv.findContours(binary, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                let referenceSquareContour = null;
                let leafContour = null;
                let maxArea = 0;

                // Filtrar y clasificar Contornos (Calibraci√≥n y Hoja)
                for (let i = 0; i < contours.size(); ++i) {
                    let contour = contours.get(i);
                    let area = cv.contourArea(contour);

                    if (area < Config.MIN_CONTOUR_AREA_PX) continue;

                    let perimeter = cv.arcLength(contour, true);
                    let approx = new cv.Mat();
                    cv.approxPolyDP(contour, approx, 0.04 * perimeter, true);
                    
                    // Solo si tiene 4 esquinas (candidato a cuadrado/referencia)
                    if (approx.rows === 4) {
                        let rect = cv.boundingRect(contour);
                        let aspectRatio = rect.width / rect.height;

                        if (aspectRatio >= Config.SQUARE_ASPECT_RATIO_MIN && aspectRatio <= Config.SQUARE_ASPECT_RATIO_MAX) {
                            referenceSquareContour = contour;
                        }
                    }

                    // El contorno m√°s grande que no es el cuadrado es la hoja
                    if (area > maxArea) {
                        // Evitar que el contorno del cuadrado sea la hoja (si ya fue detectado como cuadrado)
                        if (!referenceSquareContour || !contour.isEqual(referenceSquareContour)) {
                            maxArea = area;
                            leafContour = contour;
                        }
                    }
                    approx.delete();
                }

                let calibrationSuccess = false;
                let areaCm2 = 0;
                let perimeterCm = 0;
                let lengthCm = 0;
                let widthCm = 0;

                // 1. C√ÅLCULO DE ESCALA
                if (referenceSquareContour) {
                    const rect = cv.minAreaRect(referenceSquareContour);
                    const size = rect.size;
                    const sidePx = (size.width + size.height) / 2; // Promedio de los lados del minAreaRect
                    
                    const realSideCm = parseFloat(elements.scaleCm.value);
                    pixelsPerCm = sidePx / realSideCm;
                    calibrationSuccess = true;
                    
                    if (calculateMetrics) {
                        elements.pixelCm.textContent = `${pixelsPerCm.toFixed(2)} px/cm`;
                        elements.calibrationStatus.textContent = `‚úÖ Escala calibrada: ${pixelsPerCm.toFixed(2)} px/cm.`;
                        elements.calibrationStatus.classList.remove('text-red-500');
                        elements.calibrationStatus.classList.add('text-green-600');
                    }
                } else if (calculateMetrics) {
                    pixelsPerCm = null;
                    elements.calibrationStatus.textContent = `‚ùå No se detect√≥ un cuadrado de escala v√°lido.`;
                    elements.calibrationStatus.classList.remove('text-green-600');
                    elements.calibrationStatus.classList.add('text-red-500');
                }

                // 2. MEDICI√ìN Y DIBUJO
                dst = src.clone(); // Clone the source image for drawing

                if (leafContour && calibrationSuccess && pixelsPerCm) {
                    // Dibujar contorno de la hoja (rojo)
                    cv.drawContours(dst, new cv.MatVector(leafContour), 0, [255, 0, 0, 255], 3);

                    if (calculateMetrics) {
                        // √Årea y Per√≠metro
                        const areaPx = cv.contourArea(leafContour);
                        const perimeterPx = cv.arcLength(leafContour, true);

                        areaCm2 = areaPx / (pixelsPerCm * pixelsPerCm);
                        perimeterCm = perimeterPx / pixelsPerCm;

                        // Largo y Ancho (Usando Bounding Box de √Årea M√≠nima)
                        const minRect = cv.minAreaRect(leafContour);
                        const size = minRect.size;
                        const size1Px = size.width;
                        const size2Px = size.height;
                        
                        lengthCm = Math.max(size1Px, size2Px) / pixelsPerCm;
                        widthCm = Math.min(size1Px, size2Px) / pixelsPerCm;
                        
                        // Dibujar el Bounding Box de la hoja (rect√°ngulo rotado, amarillo)
                        let vertices = cv.boxPoints(minRect);
                        let corners = cv.matFromArray(4, 1, cv.CV_32FC2, [vertices.data32F[0], vertices.data32F[1], vertices.data32F[2], vertices.data32F[3], vertices.data32F[4], vertices.data32F[5], vertices.data32F[6], vertices.data32F[7]]);
                        cv.polylines(dst, [corners], true, [255, 255, 0, 255], 2, cv.LINE_AA);
                        corners.delete();
                    }
                }
                
                // Dibujar contorno del cuadrado (verde)
                if (referenceSquareContour) {
                    cv.drawContours(dst, new cv.MatVector(referenceSquareContour), 0, [0, 255, 0, 255], 3);
                }

                // Mostrar el resultado en el canvas
                cv.imshow(canvasOutput, dst);

                const endTime = performance.now();
                const processingTime = (endTime - startTime).toFixed(2);
                if (calculateMetrics) {
                    elements.processingTime.textContent = `${processingTime} ms`;
                }

                return { areaCm2, perimeterCm, lengthCm, widthCm, calibrationSuccess };

            } catch (e) {
                // En el loop de streaming, simplemente ignoramos frames con errores
                // En la medici√≥n final, mostramos la alerta
                if (calculateMetrics) {
                    console.error("Error en el procesamiento de OpenCV:", e);
                    showAlertModal("Error de Visi√≥n por Computadora: " + e.message);
                }
                return null;
            } finally {
                // Liberar memoria de OpenCV
                if (gray) gray.delete();
                if (binary) binary.delete();
                if (contours) contours.delete();
                if (hierarchy) hierarchy.delete();
                if (dst) dst.delete();
            }
        }

        /**
         * Funci√≥n principal para medir la imagen final (tomar foto o imagen cargada).
         */
        function measureFinalImage() {
            if (!cvReady) { showAlertModal("OpenCV.js a√∫n no est√° cargado."); return; }
            if (streaming) {
                 // Capturar frame del video
                const video = elements.webcamFeed;
                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                // lastFrame ya debe tener el Mat correcto
                stopCamera();
                // Mostramos la imagen capturada en el panel original
                elements.originalImage.src = canvas.toDataURL('image/jpeg');
                elements.originalImage.classList.remove('hidden');
                elements.webcamFeed.classList.add('hidden');

            } else if (!imageBase64) {
                showAlertModal("Por favor, cargue una imagen o inicie la c√°mara.");
                return;
            }

            const realSideCm = parseFloat(elements.scaleCm.value);
            
            if (isNaN(realSideCm) || realSideCm <= 0) {
                showAlertModal("Ingrese un valor de lado real (cm) v√°lido (> 0).");
                return;
            }

            // Usamos el √∫ltimo frame capturado (si viene de la c√°mara) o cargamos la imagen.
            let src = null;
            if (lastFrame) {
                src = lastFrame.clone();
            } else {
                 // Cargar Mat de la imagen cargada
                const imgElement = elements.originalImage;
                src = cv.imread(imgElement);
            }
            
            initializeCanvas(src);
            elements.canvasPlaceholder.classList.add('hidden');
            elements.processedCanvas.classList.remove('hidden');

            const result = processImage(src, elements.processedCanvas, true); // true para calcular m√©tricas

            if (result && result.calibrationSuccess) {
                elements.areaResult.textContent = `${result.areaCm2.toFixed(2)} cm¬≤`;
                elements.perimeterResult.textContent = `${result.perimeterCm.toFixed(2)} cm`;
                elements.lengthResult.textContent = `${result.lengthCm.toFixed(2)} cm`;
                elements.widthResult.textContent = `${result.widthCm.toFixed(2)} cm`;
            } else {
                elements.areaResult.textContent = "N/A";
                elements.perimeterResult.textContent = "N/A";
                elements.lengthResult.textContent = "N/A";
                elements.widthResult.textContent = "N/A";
            }
            
            if (src) src.delete();
        }
        
        // =======================================================
        // C√ÅMARA Y STREAMING CV
        // =======================================================
        
        let videoCap = null; // Para la captura del video en el loop

        /**
         * Loop principal de procesamiento en tiempo real.
         */
        function processVideo() {
            if (!streaming || !cvReady) {
                return;
            }

            let src = new cv.Mat(elements.webcamFeed.videoHeight, elements.webcamFeed.videoWidth, cv.CV_8UC4);
            videoCap.read(src); // Capturar frame del video

            initializeCanvas(src); // Asegura que el canvas de salida tenga el tama√±o correcto
            
            // Ejecutar el procesamiento de CV (sin calcular m√©tricas finales, solo visualizaci√≥n)
            const result = processImage(src, elements.processedCanvas, false); 
            
            // Guardar el frame actual para la medici√≥n final
            if (lastFrame) lastFrame.delete();
            lastFrame = src.clone();
            src.delete();
            
            // Repetir el loop
            requestAnimationFrame(processVideo);
        }

        /**
         * Inicia el flujo de la c√°mara web y el loop de procesamiento en tiempo real.
         */
        async function startCamera() {
            if (!cvReady) {
                showAlertModal("OpenCV.js a√∫n no est√° cargado.");
                return;
            }

            try {
                // 1. Ocultar imagen y mostrar video
                elements.originalImage.classList.add('hidden');
                elements.webcamFeed.classList.remove('hidden');
                elements.placeholderText.classList.add('hidden');
                elements.canvasPlaceholder.classList.add('hidden');
                elements.processedCanvas.classList.remove('hidden');

                // 2. Iniciar el stream de video
                stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        facingMode: "environment", // Preferir la c√°mara trasera en m√≥vil
                        width: { ideal: 640 }, // Reducir resoluci√≥n para mejor rendimiento
                        height: { ideal: 480 }
                    } 
                });
                elements.webcamFeed.srcObject = stream;
                
                // 3. Esperar a que el video est√© cargado antes de iniciar OpenCV
                elements.webcamFeed.onloadedmetadata = () => {
                    // Inicializar el objeto VideoCapture de OpenCV.js
                    if (videoCap) videoCap.delete();
                    videoCap = new cv.VideoCapture(elements.webcamFeed);
                    
                    // 4. Iniciar el loop de procesamiento en tiempo real
                    streaming = true;
                    requestAnimationFrame(processVideo);
                };
                

                // 5. Actualizar UI
                elements.btnCamera.classList.add('hidden');
                elements.btnStopCamera.classList.remove('hidden');
                elements.btnMeasure.disabled = false;

            } catch (err) {
                showAlertModal("Error al acceder a la c√°mara. Aseg√∫rese de tener permisos y una c√°mara conectada.");
                console.error("Error al acceder a la c√°mara: ", err);
                stopCamera();
            }
        }

        /**
         * Detiene el flujo de la c√°mara web y el loop de procesamiento.
         */
        function stopCamera() {
            streaming = false;
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            if (lastFrame) { lastFrame.delete(); lastFrame = null; }
            if (videoCap) { videoCap.delete(); videoCap = null; }

            elements.webcamFeed.classList.add('hidden');
            elements.placeholderText.classList.remove('hidden');
            elements.canvasPlaceholder.classList.remove('hidden');
            elements.processedCanvas.classList.add('hidden');

            elements.btnCamera.classList.remove('hidden');
            elements.btnStopCamera.classList.add('hidden');
            elements.btnMeasure.disabled = true;
        }

        // =======================================================
        // MANEJO DE IMAGEN CARGADA
        // =======================================================

        /**
         * Carga una imagen del disco y la muestra en el visor.
         */
        function handleFile(event) {
            stopCamera(); // Detener el stream si est√° activo

            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                imageBase64 = e.target.result;
                displayImage(imageBase64);
                elements.btnMeasure.disabled = false;
            };
            reader.readAsDataURL(file);
        }

        /**
         * Muestra la imagen cargada en el elemento de imagen original y limpia resultados.
         */
        function displayImage(base64Data) {
            elements.placeholderText.classList.add('hidden');
            elements.originalImage.src = base64Data;
            elements.originalImage.classList.remove('hidden');

            // Limpiar canvas anterior
            elements.processedCanvas.classList.add('hidden');
            elements.canvasPlaceholder.classList.remove('hidden');

            elements.areaResult.textContent = "N/A";
            elements.perimeterResult.textContent = "N/A";
            elements.lengthResult.textContent = "N/A";
            elements.widthResult.textContent = "N/A";
            elements.pixelCm.textContent = "N/A";
            elements.calibrationStatus.textContent = cvReady ? "Imagen cargada. Listo para medir." : "Cargando OpenCV.js...";
            elements.calibrationStatus.classList.add('text-red-500');
        }

    </script>
</body>
</html>